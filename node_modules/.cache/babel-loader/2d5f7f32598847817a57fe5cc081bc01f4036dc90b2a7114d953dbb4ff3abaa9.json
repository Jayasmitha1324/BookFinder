{"ast":null,"code":"// src/api/openLibrary.js\nconst BASE = 'https://openlibrary.org';\n\n/**\n * Robust search wrapper for OpenLibrary.\n * - Supports retry on intermittent empty pages\n * - Accepts limit to keep page size consistent\n */\nexport async function searchBooks({\n  q,\n  author,\n  year,\n  language,\n  page = 1,\n  limit = 12,\n  maxRetries = 3,\n  retryDelayMs = 400\n}) {\n  if (!q || !q.trim()) return {\n    docs: [],\n    numFound: 0\n  };\n  const makeUrl = () => {\n    const params = new URLSearchParams();\n    params.set('q', q.trim());\n    if (author) params.set('author', author.trim());\n    if (year) params.set('first_publish_year', year.trim());\n    if (language) params.set('language', language.toLowerCase());\n    params.set('page', page);\n    // OpenLibrary supports 'limit' but behavior is not always guaranteed; still pass it for consistency\n    params.set('limit', limit);\n    return `${BASE}/search.json?${params.toString()}`;\n  };\n  const url = makeUrl();\n\n  // Helper to fetch and parse JSON (with network error handling)\n  async function fetchOnce() {\n    const res = await fetch(url);\n    if (!res.ok) {\n      throw new Error(`API error: ${res.status}`);\n    }\n    return res.json();\n  }\n\n  // Try up to maxRetries if docs empty while numFound > 0\n  let attempt = 0;\n  let lastErr = null;\n  while (attempt < maxRetries) {\n    try {\n      const data = await fetchOnce();\n\n      // If docs are empty but numFound > 0, we treat as transient and retry (up to maxRetries)\n      if ((!data.docs || data.docs.length === 0) && data.numFound > 0) {\n        attempt += 1;\n        // small backoff\n        await new Promise(res => setTimeout(res, retryDelayMs * attempt));\n        // continue to next attempt\n        lastErr = new Error('Empty docs on page, retrying');\n        continue;\n      }\n\n      // Normal return\n      return data;\n    } catch (err) {\n      lastErr = err;\n      // network error: retry a few times with backoff\n      attempt += 1;\n      await new Promise(res => setTimeout(res, retryDelayMs * attempt));\n    }\n  }\n\n  // If we reached here, either we exhausted retries or there's a genuine error.\n  console.error('searchBooks: failed after retries', lastErr);\n  // Return a safe object rather than throwing, so UI can decide what to keep\n  return {\n    docs: [],\n    numFound: 0,\n    error: lastErr ? lastErr.message : 'Unknown'\n  };\n}\nexport function coverUrl(id, size = 'M') {\n  if (!id) return null;\n  return `https://covers.openlibrary.org/b/id/${id}-${size}.jpg`;\n}\nexport function openLibraryUrl(key) {\n  if (!key) return BASE;\n  return `${BASE}${key}`;\n}","map":{"version":3,"names":["BASE","searchBooks","q","author","year","language","page","limit","maxRetries","retryDelayMs","trim","docs","numFound","makeUrl","params","URLSearchParams","set","toLowerCase","toString","url","fetchOnce","res","fetch","ok","Error","status","json","attempt","lastErr","data","length","Promise","setTimeout","err","console","error","message","coverUrl","id","size","openLibraryUrl","key"],"sources":["C:/Users/admin/Desktop/Book_Finder/book-finder-final/book-finder/src/api/openLibrary.js"],"sourcesContent":["// src/api/openLibrary.js\nconst BASE = 'https://openlibrary.org';\n\n/**\n * Robust search wrapper for OpenLibrary.\n * - Supports retry on intermittent empty pages\n * - Accepts limit to keep page size consistent\n */\nexport async function searchBooks({\n  q,\n  author,\n  year,\n  language,\n  page = 1,\n  limit = 12,\n  maxRetries = 3,\n  retryDelayMs = 400,\n}) {\n  if (!q || !q.trim()) return { docs: [], numFound: 0 };\n\n  const makeUrl = () => {\n    const params = new URLSearchParams();\n    params.set('q', q.trim());\n    if (author) params.set('author', author.trim());\n    if (year) params.set('first_publish_year', year.trim());\n    if (language) params.set('language', language.toLowerCase());\n    params.set('page', page);\n    // OpenLibrary supports 'limit' but behavior is not always guaranteed; still pass it for consistency\n    params.set('limit', limit);\n    return `${BASE}/search.json?${params.toString()}`;\n  };\n\n  const url = makeUrl();\n\n  // Helper to fetch and parse JSON (with network error handling)\n  async function fetchOnce() {\n    const res = await fetch(url);\n    if (!res.ok) {\n      throw new Error(`API error: ${res.status}`);\n    }\n    return res.json();\n  }\n\n  // Try up to maxRetries if docs empty while numFound > 0\n  let attempt = 0;\n  let lastErr = null;\n\n  while (attempt < maxRetries) {\n    try {\n      const data = await fetchOnce();\n\n      // If docs are empty but numFound > 0, we treat as transient and retry (up to maxRetries)\n      if ((!data.docs || data.docs.length === 0) && data.numFound > 0) {\n        attempt += 1;\n        // small backoff\n        await new Promise((res) => setTimeout(res, retryDelayMs * attempt));\n        // continue to next attempt\n        lastErr = new Error('Empty docs on page, retrying');\n        continue;\n      }\n\n      // Normal return\n      return data;\n    } catch (err) {\n      lastErr = err;\n      // network error: retry a few times with backoff\n      attempt += 1;\n      await new Promise((res) => setTimeout(res, retryDelayMs * attempt));\n    }\n  }\n\n  // If we reached here, either we exhausted retries or there's a genuine error.\n  console.error('searchBooks: failed after retries', lastErr);\n  // Return a safe object rather than throwing, so UI can decide what to keep\n  return { docs: [], numFound: 0, error: lastErr ? lastErr.message : 'Unknown' };\n}\n\nexport function coverUrl(id, size = 'M') {\n  if (!id) return null;\n  return `https://covers.openlibrary.org/b/id/${id}-${size}.jpg`;\n}\n\nexport function openLibraryUrl(key) {\n  if (!key) return BASE;\n  return `${BASE}${key}`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}